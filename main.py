import requests
import json

#paste API keys here
ELEVENLABS_API_KEY = ''
OPENAI_API_KEY = ''

def get_voiceID_dict(elevenlabs_api_key):
    """
    Gets all voices available to your account

    :param elevenlabs_api_key: String representing the API key
    :return: Unformatted JSON response of all available voices
    """
    headers = {
        'accept': 'application-json',
        'xi-api-key': elevenlabs_api_key,
    }
    response = requests.get('https://api.elevenlabs.io/v1/voices', headers=headers)
    response_json = json.loads(response.content)
    return response_json

def get_voice(voice_id, text, key=ELEVENLABS_API_KEY):
    """
    Gets the raw data in a specified voice for a specified text string.
    Returns None if the API call fails.

    :param voice_id: The speaker you want to hear
    :param text: The text string to speak
    :param key: Your API key for ElevenLabs
    :return: Raw voice data
    """
    url = 'https://api.elevenlabs.io/v1/text-to-speech/' + voice_id
    headers = {
        'accept': 'audio/mpeg',
        'xi-api-key': key,
        'Content-Type': 'application/json',
    }
    payload = {
        "text": text
    }
    response = requests.post(url, headers=headers, json=payload)

    if response.status_code == 200:
            return response.content
    else: return None


# with open("testalexvoice.wav", 'wb') as f:
#     f.write(get_voice('IhjBds864xnXAJND0z44',"Hey, I'm walkin' here!"))

def clean_conversation_output(line):
    """
    Helper function for cleaning speaker IDs out of a generated GPT-3 conversation

    :param line: The input line generated by GPT-3
    :return: A cleaned string without speaker IDs
    """
    for x in ["\nPerson 1:","\n\nPerson 1:","\nPerson 2:","\n\nPerson 2:","\n\n(Person 1)","\n\n(Person 2)","\n\n(Person 1:)","\n\n(Person 2:)"]:
        if line.startswith(x):
            line = line.replace(x,"")
    line = line.replace("Person 1:","")
    line = line.replace("Person 2:","")
    line = line.replace("Person 1","")
    line = line.replace("Person 2","")
    return line


def gpt3_return_output(prompt, key=OPENAI_API_KEY, max_tokens=250, model="text-davinci-003",temperature=0.82):
    """
    Returns a text string from GPT-3 after an API call with a prompt and generation settings.

    :param prompt: String to prompt GPT-3 with
    :param key: OpenAI API key
    :param max_tokens: Maximum number of tokens to generate
    :param model: GPT-3 model
    :param temperature: Likeliness of the model to produce repetitive, derivative output. Max is 1.
    :return: A text response from GPT-3
    """
    headers = {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + key,
    }
    json_data = {
        'model': model,
        'prompt': prompt,
        'temperature': temperature,
        'max_tokens': max_tokens,
    }
    response = requests.post('https://api.openai.com/v1/completions', headers=headers, json=json_data)
    response_json = json.loads(response.content)
    output = response_json['choices'][0]['text']
    print(output)
    return output

def create_prompt_string(subject="",middle="", chat_middle=""):
    """
    This is a method that wraps a simplified prompt in longer boilerplate text to easily generate something that would require more prompt conditioning.
    In this example, the prompt is for a back-and-forth argument about a custom topic.

    :param subject: The subject of the prompt.
    :param middle: Text to inject as a way to give the final prompt string "memory" about a previous conversation
    :param chat_middle: Not really sure what I'm doing here tbh.
    :return: A long and customized string for prompting an LLM.
    """
    chat_intro = "This is a chat transcript, without speaker labels, between two people who are having a serious argument "+subject+". The two people do not care for each other's well being. They insult one another."
    chat_middle += middle
    chat_end = "\n\n Write exactly one brief line of the chat to continue, starting with the next speaker. Write a complete sentence. Do not include a response. The line does not contain any line breaks or newline characters:"
    prompt = chat_intro+chat_middle+chat_end
    return prompt


def audio_conversation(starter_prompt,voice1,voice2, turn_count,max_tokens=25,temperature=0.6):
    """
    Creates a back and forth conversation using two voices and a prompt.

    :param starter_prompt: A short summary of what the conversation is about.
    :param voice1: ElevenLabs voice ID for the first speaker
    :param voice2: ElevenLabs voice ID for the second speaker
    :param turn_count: Number of times to switch speakers
    :param max_tokens: Token length for GPT-3 responses
    :param temperature: GPT-3 temperature
    :return: Data that can be written to a WAV file, switching between two speakers, having a natural conversation.
    The data is formatted into a dictionary where index 0 is the WAV data and index 1 is the string representing the full conversation transcript.
    """
    text_line = gpt3_return_output(create_prompt_string(starter_prompt),max_tokens=max_tokens,temperature=temperature)
    # this line prompts GPT-3 with the custom expanded prompt created by create_prompt_string, resulting in the first line of generated conversation
    conversation = get_voice(voice1,text_line)
    # this starts a "conversation" variable that holds generated audio data. Each line of the conversation will be added to this variable.
    transcript = text_line
    for x in range(0, turn_count):
        if x < turn_count:
            text_line = gpt3_return_output(create_prompt_string(starter_prompt,middle=transcript),max_tokens=max_tokens,temperature=temperature)
            # this line prompts GPT-3 again, this time using the "middle" parameter to insert the transcript of the existing conversation.
            if x % 2 == 0:
                conversation += get_voice(voice2,text_line)
            else:
                conversation += get_voice(voice1,text_line)
            # this loop switches speaker ID based on the turn number
            transcript += text_line
            # this adds the newly-generated next line of dialogue to the transcript. The transcript serves two functions:
            # First, it gets optionally written out later as a TXT file.
            # Second, it gets fed back into the prompt on the next loop so that the prompt has the memory of the full conversation.
    return [conversation, transcript]


# This section is for testing the various functions.

testprompt = "about addiction to AI-generated deepfakes. The first person spends all his time looking at them, and the other is trying to warn him away. Include detailed descriptions of the addict's destructive behavior in the dialogue."

testconversation = audio_conversation(testprompt,'IhjBds864xnXAJND0z44','lEOEctIdusALaZkXFtPc',3,max_tokens=30,temperature=0.5)

with open("outputs/testconversation_argument.wav", 'wb') as f:
    f.write(testconversation[0])

with open("outputs/testconversation_argument.txt","w") as f:
    f.write(testconversation[1])
